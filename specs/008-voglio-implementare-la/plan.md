# Implementation Plan: Serverless Architecture con R2 Storage

**Branch**: `008-voglio-implementare-la` | **Date**: 2025-10-11 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/008-voglio-implementare-la/spec.md`

## Execution Flow (/plan command scope)
```
✓ 1. Feature spec loaded successfully
✓ 2. Technical Context filled (no NEEDS CLARIFICATION - all resolved in spec discussion)
✓ 3. Constitution Check completed (see below)
✓ 4. Constitution evaluation: PASS (simplicity principle followed)
→ 5. Phase 0: Research execution (in progress)
→ 6. Phase 1: Design & Contracts
→ 7. Re-evaluate Constitution Check
→ 8. Phase 2: Task Planning Approach
→ 9. STOP - Ready for /tasks
```

## Summary

**Primary Requirement**: Migrate from dedicated backend (Fly.io) to serverless architecture using Netlify Functions + Cloudflare R2 for file storage, with 48-hour automatic retention.

**Technical Approach**:
- Replace Express.js backend with Next.js API Routes (serverless)
- Direct browser uploads to R2 via presigned URLs (no backend intermediary)
- Netlify Scheduled Functions for automatic cleanup every 6 hours
- Maintain Supabase for metadata only (no file storage)

**Key Benefit**: Zero backend infrastructure costs (~$0-1/month vs $10.50/month)

## Technical Context

**Language/Version**: TypeScript 5.3+, Node.js 20 LTS (Next.js 14), React 18
**Primary Dependencies**:
- Next.js 14 App Router (serverless functions)
- @aws-sdk/client-s3 (R2 interaction - S3-compatible API)
- @aws-sdk/s3-request-presigner (signed URLs)
- Supabase Client (metadata & auth)
**Storage**: Cloudflare R2 (file storage), Supabase PostgreSQL (metadata only)
**Testing**: Vitest (contract + integration tests)
**Target Platform**: Netlify (serverless functions + scheduled functions + CDN)
**Project Type**: Web (frontend-only with serverless functions)
**Performance Goals**:
- Upload initiation: <500ms (presigned URL generation)
- Download initiation: <500ms (signed URL generation)
- Actual upload/download: CDN-dependent (R2 global network)
**Constraints**:
- 48-hour file retention (strict)
- Max file size: 1GB
- Netlify Function timeout: 10s (sufficient for URL generation only)
- Scheduled Function runs every 6 hours
**Scale/Scope**: 20-30 events/week, ~250 files/week, ~12.5GB active storage

## Constitution Check

### I. No Easy Fixes ✓
- Direct R2 uploads eliminate backend bottleneck (proper solution)
- Presigned URLs are security best practice for large file uploads
- Not a workaround, but recommended architecture for serverless + object storage

### II. Security First ✓
- Presigned URLs: time-limited (1h), single-use intent
- Download URLs: validated against event access (RLS policies)
- R2 bucket: not publicly browsable, only signed URL access
- Existing RLS policies remain active for metadata access

### III. Test-Driven Development ✓
- Contract tests for presigned URL generation API
- Contract tests for download URL generation API
- Integration tests for 48h retention enforcement
- Tests written before implementation (TDD maintained)

### IV. Multi-Tenant Isolation ✓
- R2 keys include tenant_id prefix: `tenant-{id}/event-{id}/`
- Existing RLS policies enforce tenant-scoped metadata access
- No changes to multi-tenant architecture

### V. UX-First Design ✓
- Direct upload: no backend hop, faster uploads
- CDN downloads: globally fast access
- No user-facing changes (internal architecture only)

### VI. Simplicity ✓
- **Eliminates** dedicated backend (Fly.io) → simpler ops
- **Eliminates** backend file handling → simpler code
- Uses proven pattern (presigned URLs) → industry standard
- Fewer moving parts than current architecture

**Result**: ✅ PASS - Architecture simplification, no violations

## Project Structure

### Documentation (this feature)
```
specs/008-voglio-implementare-la/
├── plan.md              # This file
├── research.md          # Phase 0: R2 integration patterns
├── data-model.md        # Phase 1: Updated slide schema
├── quickstart.md        # Phase 1: Manual test scenarios
├── contracts/           # Phase 1: API contracts
│   ├── presigned-upload.yml
│   ├── presigned-download.yml
│   └── cleanup-scheduled.yml
└── tasks.md             # Phase 2: Generated by /tasks command
```

### Source Code (repository root)
```
frontend/
├── src/
│   ├── app/
│   │   └── api/           # ← NEW: Next.js API Routes (serverless)
│   │       ├── slides/
│   │       │   ├── presigned-upload/
│   │       │   │   └── route.ts      # Generate R2 upload URL
│   │       │   ├── presigned-download/
│   │       │   │   └── route.ts      # Generate R2 download URL
│   │       │   └── [id]/
│   │       │       └── route.ts      # Metadata CRUD
│   │       └── cleanup/
│   │           └── route.ts          # Scheduled cleanup (Netlify)
│   ├── components/
│   │   └── admin/
│   │       └── SlideUpload.tsx       # ← MODIFIED: Direct R2 upload
│   ├── lib/
│   │   ├── r2.ts                     # ← NEW: R2 client wrapper
│   │   └── supabase.ts               # Existing
│   └── types/
│       └── slide.ts                  # ← MODIFIED: Add r2_key field
└── tests/
    ├── contract/
    │   ├── presigned-upload.test.ts  # ← NEW
    │   ├── presigned-download.test.ts # ← NEW
    │   └── cleanup.test.ts           # ← NEW
    └── integration/
        └── retention.test.ts         # ← NEW: 48h enforcement

backend/                               # ← TO BE REMOVED
├── fly.toml                          # Delete
├── Dockerfile                        # Delete
└── src/                              # Migrate to frontend/src/app/api

netlify.toml                          # ← MODIFIED: Add scheduled function
```

**Structure Decision**: Web application (frontend-only) with Next.js API Routes replacing dedicated Express backend. Backend folder will be deprecated after migration completes.

## Phase 0: Outline & Research

**Unknowns to Research**:
1. Cloudflare R2 presigned URL generation (SDK usage)
2. Netlify Scheduled Functions (cron syntax, reliability)
3. Next.js API Routes best practices for file operations
4. R2 bucket configuration (CORS, public access settings)
5. Migration strategy for existing slides (if any)

**Research Output** (`research.md` will contain):
- **Decision 1**: Use AWS SDK v3 (@aws-sdk/client-s3) - R2 is S3-compatible
- **Decision 2**: Netlify Scheduled Functions via `netlify.toml` configuration
- **Decision 3**: Next.js Route Handlers (App Router) for API endpoints
- **Decision 4**: R2 bucket with CORS enabled, no public listing
- **Decision 5**: Existing slides remain on current storage (out of scope for this feature)

**Output**: research.md with implementation patterns and code examples

## Phase 1: Design & Contracts

### Entities (`data-model.md`)

**Updated Entity: Slide**
```
Slide {
  id: UUID (primary key)
  session_id: UUID (foreign key → sessions)
  filename: STRING (original upload name)
  file_size: BIGINT (bytes)
  mime_type: STRING (e.g., 'application/pdf')
  r2_key: STRING ← NEW (R2 object path: 'tenant-{id}/event-{id}/slide-{id}')
  uploaded_at: TIMESTAMP ← INDEXED for cleanup queries
  deleted_at: TIMESTAMP | NULL (soft delete marker)
  tenant_id: UUID (for RLS)
}

Indexes:
- uploaded_at (for cleanup job: WHERE uploaded_at < NOW() - INTERVAL '48 hours')
- tenant_id + session_id (for event queries)
```

### API Contracts (`/contracts/`)

**1. Generate Presigned Upload URL**
```yaml
# contracts/presigned-upload.yml
POST /api/slides/presigned-upload
Request:
  body:
    session_id: uuid
    filename: string
    file_size: number (max 1073741824)  # 1GB
    mime_type: string (enum: application/pdf, application/vnd.ms-powerpoint, ...)

Response 200:
  upload_url: string (presigned URL, valid 1h)
  slide_id: uuid (created metadata record)
  r2_key: string (for upload completion callback)

Response 400:
  error: "File size exceeds limit" | "Invalid file type" | ...

Response 401:
  error: "Unauthorized"
```

**2. Generate Presigned Download URL**
```yaml
# contracts/presigned-download.yml
GET /api/slides/:id/download
Params:
  id: uuid

Response 200:
  download_url: string (presigned URL, valid 1h)
  filename: string
  file_size: number

Response 404:
  error: "File deleted or expired"

Response 403:
  error: "Access denied"
```

**3. Scheduled Cleanup**
```yaml
# contracts/cleanup-scheduled.yml
POST /api/cleanup (internal, triggered by Netlify cron)

Process:
  1. Query slides WHERE uploaded_at < NOW() - INTERVAL '48 hours' AND deleted_at IS NULL
  2. For each: DELETE from R2, UPDATE deleted_at = NOW()
  3. Log summary

Response 200:
  deleted_count: number
  errors: string[]
```

### Contract Tests (failing initially)

**Location**: `frontend/tests/contract/`

**Test 1**: `presigned-upload.test.ts`
```typescript
test('POST /api/slides/presigned-upload returns valid presigned URL', async () => {
  const res = await request(app).post('/api/slides/presigned-upload').send({
    session_id: 'uuid',
    filename: 'test.pdf',
    file_size: 1024,
    mime_type: 'application/pdf'
  });

  expect(res.status).toBe(200);
  expect(res.body).toMatchObject({
    upload_url: expect.stringContaining('r2.cloudflarestorage.com'),
    slide_id: expect.any(String),
    r2_key: expect.stringContaining('tenant-')
  });

  // Validate presigned URL expiry
  const url = new URL(res.body.upload_url);
  expect(url.searchParams.has('X-Amz-Expires')).toBe(true);
});
```

**Test 2**: `presigned-download.test.ts` (similar structure)
**Test 3**: `cleanup.test.ts` (tests 48h logic)

### Quickstart Test (`quickstart.md`)

**Manual Test Scenario**:
```markdown
## Quickstart: Upload & Download Flow

### Prerequisites
- R2 bucket created: `sharehub-slides`
- Env vars set: R2_ACCOUNT_ID, R2_ACCESS_KEY_ID, R2_SECRET_ACCESS_KEY

### Test Steps
1. **Upload**:
   - Navigate to admin panel → event → session
   - Select file (test.pdf, 5MB)
   - Observe: direct upload to R2 (no backend progress bar)
   - Verify: metadata in Supabase, file in R2 bucket

2. **Download**:
   - Navigate to public event page
   - Click download link
   - Verify: fast CDN download

3. **Retention**:
   - Manually trigger cleanup: `curl -X POST https://your-site.netlify.app/api/cleanup`
   - Verify: files >48h deleted from R2 and marked in DB

### Success Criteria
- Upload completes for 1GB file
- Download URL works immediately
- Cleanup deletes old files correctly
```

### Agent Context Update

Will run: `powershell .specify/scripts/powershell/update-agent-context.ps1 -AgentType claude`

Expected CLAUDE.md additions:
- Cloudflare R2 usage (@aws-sdk/client-s3)
- Netlify Scheduled Functions pattern
- Presigned URL generation patterns

**Output**: data-model.md, contracts/, failing tests, quickstart.md, updated CLAUDE.md

## Phase 2: Task Planning Approach

**Task Generation Strategy** (for `/tasks` command):
1. Load data-model.md → DB migration task
2. Load each contract → contract test task [P]
3. Load contracts → implementation tasks (sequential)
4. Load quickstart → integration test tasks

**Estimated Tasks**:
1. [P] Write contract test: presigned-upload
2. [P] Write contract test: presigned-download
3. [P] Write contract test: cleanup
4. Create DB migration: add r2_key, index uploaded_at
5. Implement R2 client wrapper (lib/r2.ts)
6. Implement presigned-upload API route
7. Implement presigned-download API route
8. Implement cleanup scheduled function
9. Update SlideUpload component (direct R2)
10. Configure Netlify scheduled function (netlify.toml)
11. [P] Integration test: 48h retention
12. Manual quickstart validation
13. Remove backend folder (deprecation)
14. Update documentation (DEPLOYMENT.md)

**Ordering**: Tests first (1-3), then DB (4), then implementation (5-10), then validation (11-14)

**Output**: ~14 numbered tasks in tasks.md (generated by `/tasks` command)

## Phase 3+: Future Implementation

**Phase 3**: Execute tasks.md following TDD (tests → implementation)
**Phase 4**: Deploy to Netlify, configure R2 bucket, test in production
**Phase 5**: Monitor costs, validate 48h retention in production

## Complexity Tracking

*No constitutional violations - architecture simplifies existing system*

## Progress Tracking

**Phase Status**:
- [x] Phase 0: Research complete (R2 patterns documented)
- [ ] Phase 1: Design complete (next step)
- [ ] Phase 2: Task planning described (waiting for /tasks)
- [ ] Phase 3: Tasks generated (/tasks command)
- [ ] Phase 4: Implementation complete
- [ ] Phase 5: Validation passed

**Gate Status**:
- [x] Initial Constitution Check: PASS
- [ ] Post-Design Constitution Check: PASS (after Phase 1)
- [x] All NEEDS CLARIFICATION resolved
- [x] Complexity deviations documented (none)

---
*Based on Constitution v2.1.1 - See `.specify/memory/constitution.md`*
